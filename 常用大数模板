1、快速幂模板
ll quick(ll a, ll b,ll mod) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a%mod;
        b >>= 1;
        a = a * a%mod;
    }
    return res;
}

2、求phi模板
ll phi(ll m) {
    ll ans = 1;
    for (ll i = 2; i*i <= m; i++) {
        if (m%i == 0) {
            m /= i;
            ans *= i - 1;
            while (m%i == 0) {
                m /= i;
                ans *= i;
            }
        }
    }
    if (m > 1) ans *= m - 1;
    return ans;
}

3、大数取模模板
ll Mod(string a,ll b)
{
    ll len=a.length()-1;
    ll ans=0;
    for(int i=0;i<=len;i++)
        ans=(ans*10+(a[i]-'0')%b)%b;
    return ans;
}

4、大数相乘模板
string Mul(string s,int x){
    reverse(s.begin(),s.end());
    int cmp=0;
    for(int i=0;i<s.size();i++){
        cmp=(s[i]-'0')*x+cmp;
        s[i]=(cmp%10+'0');
        cmp/=10;
    }
    while(cmp){
        s+=(cmp%10+'0');
        cmp/=10;
    }
    reverse(s.begin(),s.end());
    return s;
}

5、大数相加模板：
string sum(string s1,string s2)
{
    if(s1.length()<s2.length())
    {
        string temp=s1;
        s1=s2;
        s2=temp;
    }
    int i,j;
    for(i=s1.length()-1,j=s2.length()-1;i>=0;i--,j--)
    {
        s1[i]=char(s1[i]+(j>=0?s2[j]-'0':0));   //注意细节
        if(s1[i]-'0'>=10)
        {
            s1[i]=char((s1[i]-'0')%10+'0');
            if(i) s1[i-1]++;
            else s1='1'+s1;
        }
    }
    return s1;
}

6、__int128 2^128次使用,只能在Linux下使用
inline __int128 read() {
    __int128 x = 0, f = 1;
    char ch = getchar();
    while (ch<'0' || ch>'9') {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0'&&ch <= '9') {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * f;
}

inline void print(__int128 x) {
    if (x < 0) {
        putchar('-');
        x = -x;
    }
    if (x > 9)
        print(x / 10);
    putchar(x % 10 + '0');
}

其他时候可以使用printf,cin,cout

7、java大数
import java.math.BigInteger;
import java.util.Scanner;

public class Main{	
	public static void main(String[] args) {
		Scanner cin=new Scanner(System.in);
		BigInteger a,b,c;
		int t;
		t = cin.nextInt();
		for(int i=1;i<=t;i++){
			a=cin.nextBigInteger();
			b=cin.nextBigInteger();
			c=cin.nextBigInteger();
			System.out.println(a.modPow(b, c));
		}
	}
}

8、快速乘
//O(1)快速乘
inline LL quick_mul(LL x,LL y,LL MOD){
    x=x%MOD,y=y%MOD;
    return ((x*y-(LL)(((long double)x*y+0.5)/MOD)*MOD)%MOD+MOD)%MOD;
}
//O(log)快速乘
inline LL quick_mul(LL a,LL n,LL m)
{
    LL ans=0;
    while(n)
    {
        if(n&1) ans=(ans+a)%m;
        a=(a<<1)%m;
        n>>=1;
    }
    return ans;
}

9、Censored!(poj1625)
题意：
    本题是有n个字符(1<=n<=50)，p(1<=p<=10)个被限定的不能出现的串,现求m(1<=m<=50)长字符组合数有多少个。

思路：
    显然先建立ac自动机,因为数据量非常大，肯定会爆ll,因此寻求dp+高精度计算。设dp[i][j]表示第i个字符的时候
转移到j节点有多少种情况.
