区间dp，顾名思义，就是去解决一些区间内最优值的问题，通常的时间复杂度为n^2,n^3.
它既要满足dp问题的最优子结构和无后效性外，还应该符合在区间上操作的特点。
它必定是由多个长度不一的小区间转移而来，我们通过求得多个小区间的情况，从而合并信息，得到大区间。
一般而言dp[1][n]就是结果。

1、石子归并问题 （洛谷P1880）
石子归并满足状态方程：dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+sum[i][j]); sum[i][j]指i-j的和
可以通过前缀和获得，sum[j]-s[i-1],或者sum[i][j]=sum[i][k]+sum[k][j];

for (int i = 1; i <= 2*n; i++)
	for (int j = 1; j <= 2*n; j++) {
		dp2[i][j] = 0;
		dp[i][j] = 0x3f3f3f3f;
	}
for (int i = 1; i <= 2 * n; i++) {
	dp[i][i] = 0;
	sum[i] = sum[i - 1] + a[i];
}	
for (int len = 1; len < n; len++) {
	for (int i = 1; i + len <= 2*n; i++) {
		int j = i + len;
	        for (int k = i; k < j; k++) {
			 dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] + sum[j]-sum[i-1]); //求最小值
			 dp2[i][j] = max(dp2[i][j], dp2[i][k] + dp2[k + 1][j] + sum[j] - sum[i - 1]); //求最大值
		}
	}
}

2、四边形不等式
在dp问题中,我们常遇见这样的一类问题，他们的dp转移方程式这样的：dp[i][j]=min{dp[i][k]+dp[k+1][j]+cost[i][j]}

对于(a<b<=c<d)，如果有f[a][c]+f[b][d]<=f[b][c]+f[a][d]，则说明f满足四边形不等式
1、当决策代价函数w[i][j]满足w[i][j]+w[i'][j']<=w[i'][j]+w[i][j'] (i<=i'<=j<=j')时，称满足四边形不等式
2、当函数w[i][j]满足w[i'][j]<=w[i][j'] (i<=i'<=j<=j')时,称w关于区间包含关系单调.
结论：若决策代价函数满足四边形不等式，包含关系单调，且dp[i][j]方程也满足四边形不等式，设s[i][j]表示
dp[i][j]取得最优值时对应的下标，即(i<=k<=j)。就满足s[i][j-1]<=s[i][j]<=s[i+1][j]。

一般做法：
对于dp转移合法的证明，其实很多时候直接打表就行了，比如先跑一个O（n^3）的代码，跑的时候判断是否满足四边形不
等式，决策是否单增等等，如果不满足就输出false之类的，或者打一个决策表出来观察，这样其实会省下一部分时间。

参考链接：
https://blog.csdn.net/noiau/article/details/72514812
http://www.cnblogs.com/jiu0821/p/4493497.html


3、括弧匹配（poj2955）
题意：给一段()[]组成的序列问，在保持次序列下，最大的括弧匹配数是多少。

反思:最初一直在想着如何实现状态转移方程 dp[i][k]+dp[k+1][j]+cnt,想要处理内部连接时的状态转移方程，
换个思路想，从外围入手,dp[i][j]=dp[i+1][j-1]+cnt,这也是一个状态转移方程，它能直接忽视内部变化情况，直接从
外围的情况去考虑，然后确定一个dp[i][j]后，我们可以通过dp[i][j] = max(dp[i][j],dp[i][k]+dp[k+1][j])的
状态转换方程确定最终结果。

核心代码：
for (int length = 2; length <= len; length++) {
	for (int i = 0; i + length - 1 < len; i++) {
		int j = i + length - 1;
		if((s[i]=='('&&s[j]==')')||(s[i]=='['&&s[j]==']'))
			dp[i][j] = dp[i + 1][j - 1] + 2;
		else
			dp[i][j] = dp[i + 1][j - 1];
		for (int k = i; k < j; k++) {
			dp[i][j] = max(dp[i][j], dp[i][k] + dp[k + 1][j]);
		}
	}
}



