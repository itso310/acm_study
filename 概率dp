规律总结：
1、期望可以分解成多个子期望的加权和，权为子期望发生的概率，即E(aA+bB...)=aE(A)+bE(B)+...+1
2、期望从后往前找，一般dp[n]=0,dp[0]是答案
3、解决过程，找出各种情况乘上这种情况发生的概率，求和

1、Favorite Dice (spoj)
题意：
    甩一个n面的骰子，问每一面都被甩到的次数期望是多少？

思路：
    设dp[i]表示取了i种数时还需取得数的期望，显然dp[n]=0,求解dp[0]
由于选第i个数后再选一个数与已经选过的数不同的概率为(n-i)/n，相同为i/n
于是可以得到状态转移方程 dp[i]=(n-i)/n*dp[i+1]+i/n*dp[i]+1
推得 dp[i]=dp[i+1]+n/(n-i)  只需要for循环一下即可

核心代码：
dp[n] = 0;
for (int i = n - 1; i >= 0; i--)
    dp[i] = dp[i + 1] + n /(n - i + 0.0);
printf("%.2lf\n", dp[0]);


2、LOOPS (hdu3853)
题意：
    一个女生走迷宫，只有向下和向右走和保持在原地，每走一次会消耗掉2的魔力，求从(1,1)成功走到(r,c)所花魔力的期望。

思路：
    设dp[r][c]=0，那么有满足状态转移方程 dp[i][j] = p1*dp[i][j]+p2*dp[i][j+1]+p3*dp[i+1][j]+2
转化成  dp[i][j] = (p2*dp[i][j+1]+p3*dp[i+1][j]+2)/(1-p1) 即可

核心代码：
for (int i = r; i >= 1; i--) {
    for (int j = c; j >= 1; j--) {
	if (i == r && j == c)
		continue;
	if (p[i][j].p1 == 1)
		continue;
	dp[i][j] = (p[i][j].p2*dp[i][j + 1] + 2 + p[i][j].p3*dp[i + 1][j]) / (1 - p[i][j].p1);
    }
 }
   
 反思：
    dp[i][j]表示在(i,j)这个点时，还差多少魔力值才能到达终点的期望。
    最开始的时候dp[i][j]将未来的状态也加入其中，其实那种想法是错误的，因为当前还未确定，未来也不会确定，因此状态转移方程所含
 的应该是当前不确定的dp[i][j]和之前已经推导出的状态来推导出dp[i][j]最终推导dp[1][1]的时候就是答案。
