

1、不要62(hdu2089)
题意：
  求出区间[n,m]中数位没有62和4的个数
思路：
  1、设dp[i][j]表示最高i位时,第i为j符合条件的个数。例如dp[5][0]中包含00532。数位dp的精髓就是逐位比较，最终获得答案。
设count(n)记录[0,n)的个数，因此要获得[n,m]中的个数，需要count(m+1)-count(n)。其中dp[i][j]的状态转移方程为：
1)、dp[i][j]=0 (j==4) 2)、dp[i][j]=sigma(dp[i-1][j]) (j=0,1...,9),当j=6时,需要减去dp[i-1][2]
之后就是将数位拆开，挨个去比较比如102,拆出来为201,此时先去保存100以下的数字，之后去保存102以下，100以上的数字。
最终即可获得答案。

代码：
1、
void init(){
	dp[0][0]=1;
	for(int i=1;i<10;i++){
		for(int j=0;j<10;j++){
			if(j==4){
				dp[i][j]=0;
			}else if(j!=6){
				for(int k=0;k<=9;k++)
					dp[i][j]+=dp[i-1][k];
			}else if(j==6){
				for(int k=0;k<=9;k++)
					dp[i][j]+=dp[i-1][k];
				dp[i][j]-=dp[i-1][2];
			}
		}
	}
}
int v[N+10];
ll solve(int di){
	ll res=0;
	v[0]=0;
	while(di){
		v[++v[0]]=di%10;
		di/=10;
	}
	v[v[0]+1]=0;
	for(int i=v[0];i>=1;i--){
		for(int j=0;j<v[i];j++){
			if(j!=4&&!(j==2&&v[i+1]==6))
				res+=dp[i][j];
		}
		if(v[i]==4)
			break;
		if(v[i]==2&&v[i+1]==6)
			break;
	}
	return res;
}
