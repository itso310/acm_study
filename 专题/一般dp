1.Photo Processing(cf 883I)
题意：
    给你n个数，将其进行分组，每组最少k个数，求分组方案中最小的最大值差值，其中差值为一组中max(max-min)的值

思路：
    先将答案进行二分，然后使用dp去处理，设dp[i]表示[1,i]中能否被完整分成满足条件的几段
    
代码：
方法一：通过二分的答案和k值去约束答案，如果dp[i]可行，那么标记dp[i]=1
bool check(int differ){
    memset(dp,0, sizeof(bool)*(n+2));
    int index=1;dp[0]=1;
    for(int i=1;i<=n;i++){
        while(a[i]-a[index]>differ)
            index++;
		    while(i-index+1>=k){
            if(dp[index-1]){
                dp[i]=1;break;
            }
	    index++;
        }
    }
    return dp[n];
}
方法二：last去标记最后一个能似的dp[i]成功的位置，如果dp[n]==n那么说明都可以分段
bool check(int differ){
    int last=0;
    for(int i=k;i<=n;i++){
        int j = dp[i-k];
        if(a[i]-a[j+1]<=differ)
            last=i;
        dp[i]=last;
    }
    return dp[n]==n;
}

2.小D的剧场(https://ac.nowcoder.com/acm/contest/369/A)
题意:
    一串音符，其中对于每三个都有限制，每个位置有49种音符可能，现在让你求总的可能方案数。
    
思路：
    因为每三个才有限制，第三个的方案数只取决于前两个，因此可以列出dp[500][49][49]，dp[i][j][k]表示在i种位置时
第二个位置为j，第三个位置为k的方案数，可列出：dp[t][i][j]=(dp[t][i][j]+dp[t-1][j][k])%mod;
