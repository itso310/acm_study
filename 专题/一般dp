1.Photo Processing(cf 883I)
题意：
    给你n个数，将其进行分组，每组最少k个数，求分组方案中最小的最大值差值，其中差值为一组中max(max-min)的值

思路：
    先将答案进行二分，然后使用dp去处理，设dp[i]表示[1,i]中能否被完整分成满足条件的几段
    
代码：
方法一：通过二分的答案和k值去约束答案，如果dp[i]可行，那么标记dp[i]=1
bool check(int differ){
    memset(dp,0, sizeof(bool)*(n+2));
    int index=1;dp[0]=1;
    for(int i=1;i<=n;i++){
        while(a[i]-a[index]>differ)
            index++;
		    while(i-index+1>=k){
            if(dp[index-1]){
                dp[i]=1;break;
            }
	    index++;
        }
    }
    return dp[n];
}
方法二：last去标记最后一个能似的dp[i]成功的位置，如果dp[n]==n那么说明都可以分段
bool check(int differ){
    int last=0;
    for(int i=k;i<=n;i++){
        int j = dp[i-k];
        if(a[i]-a[j+1]<=differ)
            last=i;
        dp[i]=last;
    }
    return dp[n]==n;
}

2.小D的剧场(https://ac.nowcoder.com/acm/contest/369/A)
题意:
    一串音符，其中对于每三个都有限制，每个位置有49种音符可能，现在让你求总的可能方案数。
    
思路：
    因为每三个才有限制，第三个的方案数只取决于前两个，因此可以列出dp[500][49][49]，dp[i][j][k]表示在i种位置时
第二个位置为j，第三个位置为k的方案数，可列出：dp[t][i][j]=(dp[t][i][j]+dp[t-1][j][k])%mod;

3、最少拦截系统(hdu1257)
题意：
    有n个导弹依次发射，设置的系统第一次可以打任意高度，接下来的高度不能超过上次发射高度，求最少需要几个系统才能
将导弹全部射下。

思路：
    此题其实也不算真正意义上的dp，通过求最大LIS可获得答案，而与之对应的思想是求最大LIS的贪心+二分的方法，这种
方法不能求得最大LIS的真正意义上的值，但是可以求得最大LIS的长度。就是通过这个方法不断更新，加入求得最后答案。因
为每个导弹肯定是去寻找已发射导弹中离他高度最近的导弹，如果没有导弹满足条件，那么就再设一个。从而获得最后答案。

3、Max Sum Plus Plus(hdu1024)
题意：
    给你a[N]数组，(1<=n<=1e6),求k个区间段最大值为多少。
思路：
    设dp[i][j]表示i段区间，j结尾的最大值(j纳入其中)，因此我们可以得到状态转移方程:
dp[i][j]=max{dp[i][j-1],max{dp[i-1][t](i-1<=t<=j-1)}}+a[j].前者因为dp[i][j-1]的值已知，若不增加i，只需要
将a[j]并入最后一个区间即可。后者是还缺一个区间，将a[j]视为独立区间并入其中。但是有2个max显得处理起来极其繁琐，
且(1<=n<=1e6)，因此我们可以设w[i][j]=max{dp[i][t](i<=t<=j)}=max{w[i][j-1],dp[i][j]},从而我们可以将方程化为:
1)dp[i][j]=max{dp[i][j-1],w[i-1][j-1]}+a[j] 2)w[i][j]=max{dp[i][j],w[i][j-1]}  通过观察发现可以使用滚动数
组将其空间大小进行优化，优化结果为: 1)dp[j]=max{dp[j-1],w[t^1][j-1]}+a[j] 2)w[t^1][j]=max{dp[j],w[t^1][j-1]}
针对此数组对于时间的取值上发现，取m段需要n个数，取m-1段需要n-1个数，取m-2段需要n-2个数...因此在取m-(m-i)=i段的时候，
只需要求解n-(m-i)个数组即可

核心代码：
scanf("%d",&n);
for(int i=1;i<=n;i++){
    scanf("%d",&a[i]);
    pre[i]=pre[i-1]+a[i];
    w[0][i]=0;
}
int t=1;
for(int i=1;i<=k;i++){
    dp[i]=w[t][i]=pre[i];
    for(int j=i+1;j<=n+i-k;j++){
        dp[j]=max(dp[j-1],w[t^1][j-1])+a[j];
        w[t][j]=max(dp[j],w[t][j-1]);
    }
        t^=1;
}
printf("%lld\n",w[t^1][n]);




