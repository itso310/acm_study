1.玉米田(洛谷P1879)
题意：
    有一个N*M(N<=12,M<=12)的农田，农田有肥沃的草地和干瘪的土地，现在可以放置牛，但是要求放牛的地方四周不能有其它牛，
求放置牛的方案数，其中没有放任何一头牛也算一种方案。

思路：
  这是入门状压dp题，需要注意的是对于状压dp题经常可以通过题目要求减少状态量。一般的状压的题目都会有大量的状态，枚举
所有状态需要大量的时间，时间承受不了，所以我们可以通过预处理，去掉不合法的状态，减少时空的需要。这跟STL中的map很相似
，开个state[i]的数组表示合法的数据。枚举的时候直接利用state[i]所保留的状态即可。
  对于此题有2^m个状态，因为不能有相邻为1的情况，此时可以通过 state[i] = ((i&(i>>1))==0)&&((i&(i<<1))==0); 这种巧
妙的方法去预处理。
  之后使用dp[i][j]，表示第i行时，状态为j的数量有多少个。其中要先判断 state[j]&&((j&F[i])==j) 来查看是否状态符合要
求，之后我们再枚举状态，判断(k & j) == 0是否成立。如若成立，则 dp[i][j]=(dp[i][j]+dp[i-1][k])%mod;
  最后只需要将最后一行累加起来就可以得到答案。

反思：
  这是入门状压dp题，我们可以学到状压dp多是把大量状态进行枚举筛选，然后在接下来的操作中直接使用预处理过的状态进行使用。
状压dp需要巧妙的减枝来加少时间。总儿言之就是将状态压缩，使用dp的方法求得答案。

核心代码：
for(int i=0;i<maxstate;i++)
        state[i] = ((i&(i>>1))==0)&&((i&(i<<1))==0);
dp[0][0]=1;
for(int i=1;i<=n;i++){
    for(int j=0;j<maxstate;j++){
        if(state[j]&&((j&F[i])==j)){
          for(int k=0;k<maxstate;k++){
            if((k&j)==0)
               dp[i][j]=(dp[i][j]+dp[i-1][k])%mod;
          }
        }
    }
}
