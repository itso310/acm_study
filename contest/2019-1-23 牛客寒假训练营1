1、小a与星际探索
题意：
  小a玩星际探索游戏,从1号星球出发,到n号星球。每个星球都有能量值P,要想从i星球到达j星球，需要满足能量Pi>Pj.
设飞船耐久度为t,小a在1号星球时耐久度为t,到达下一个i星球时耐久度变为t^pi，对于每个位置来说，从出发到可到达
的位置仅和两者之间的p有关

思路:
  因为飞船能不能飞仅和两个星球之间的p有关，因此我们先从小到大排序，然后开个vector，将1-n之间的推入vector.
然后考虑到p<=3000，有12位，12位最大为4096,因此可以考虑转化成背包问题，dp[0][i](bool)表示在过去状态时，
异或值为i的情况是否存在，dp[1][i]去存现状态异或值为i的情况是否存在。在还没到达最后一个点时，可以将状态不断
叠加即dp[0][i]=dp[0][i]||dp[1][i]，到最后一个点时只留下dp[1][i]即可。

核心代码：
dp[0][v[0]]=1;
int cnt = v.size();
for(int i=1;i<cnt;i++){
  for(int j=1;j<=4096;j++)
      if(dp[0][j])
         dp[1][j^v[i]]=1;
  if(i!=cnt-1)
     for(int j=1;j<=4096;j++)
         if(dp[0][j])
            dp[1][j]=1;

  for(int j=1;j<=4096;j++){
      dp[0][j]=dp[1][j];
      dp[1][j]=0;
  }
}

反思：
  异或和常针对于01二进制进行处理，此题是一个非常好的综合题，与背包问题结合起来。数据所给范围3000以内，即最高为只有12，也就是
最大值为4096,因此可以dp存储原状态去推导现状态，最后得到答案。dp题还是需要多思考多练！
